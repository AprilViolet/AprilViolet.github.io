<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>听到涛声</title>
  
  <subtitle>起风了，唯有努力生存！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://aprilviolet.github.io/"/>
  <updated>2020-05-31T01:45:34.086Z</updated>
  <id>http://aprilviolet.github.io/</id>
  
  <author>
    <name>AprilViolet</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常用的设计模式总结（四）</title>
    <link href="http://aprilviolet.github.io/article/2020.01/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://aprilviolet.github.io/article/2020.01/常用的设计模式总结（四）/</id>
    <published>2020-01-12T12:57:00.000Z</published>
    <updated>2020-05-31T01:45:34.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>介绍：通过代理，为其它对象提供一种代理以控制对这个对象的访问。可以详细控制访问某个（某类）对象的方法，我们可以在调用这个方法前做前置处理等操作</p><a id="more"></a><h1 id="代理模式的角色"><a href="#代理模式的角色" class="headerlink" title="代理模式的角色"></a>代理模式的角色</h1><p><strong>Subject（抽象角色）：</strong>定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法</p><p><strong>Real Subject（真实角色）：</strong>真正实现业务逻辑的类</p><p><strong>Proxy（代理角色）：</strong>用来代理和封装真实角色</p><h1 id="代理模式的优缺点"><a href="#代理模式的优缺点" class="headerlink" title="代理模式的优缺点"></a>代理模式的优缺点</h1><p>优点</p><ul><li>代理模式能够将代理对象与真实被调用的目标对象分离</li><li>一定程度上降低了系统的耦合度，扩展性好</li><li>保护目标对象、增强目标对象</li></ul><p>缺点</p><ul><li>代理模式会造成系统中的类的数据增加</li><li>在客户端目标对象加一个代理对象，会造成请求处理速度，慢</li><li>增加系统的复杂度</li></ul><h1 id="代理模式的分类"><a href="#代理模式的分类" class="headerlink" title="代理模式的分类"></a>代理模式的分类</h1><ul><li>静态代理</li><li>动态代理<ul><li>JDK动态代理</li><li>CGLib动态代理</li></ul></li></ul><p>理解</p><p>​    静态代理是显式地定义一个实现类的代理。在代理之前，所有的东西都是已知的，即知道我们所需要代理的类和方法</p><p>​    动态代理所有东西都是未知的，即不知道需要代理的类和方法</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>静态代理比较好理解，直接上代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object orderInfo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加Order</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> order order</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 影响行数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">saveOrder</span><span class="params">(Order order)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真实角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加Order</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> order order</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 影响行数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Service层调用Dao层添加Order"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceStaticProxy</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 被代理的类</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        beforeMethod(order);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们知道被代理的类和所需要的方法</span></span><br><span class="line">        orderService = <span class="keyword">new</span> OrderServiceImpl();</span><br><span class="line">        <span class="keyword">int</span> result = orderService.saveOrder(order);</span><br><span class="line"></span><br><span class="line">        afterMethod();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">beforeMethod</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"静态代理 before code"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">afterMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"静态代理 after code"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态代理比较理解并且容易实现，但是当场景复杂起来，当我们一旦修改了抽象角色当中需要代理的方法，那么对于代理类也是需要修改的，不易维护。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><h4 id="动态代理的实现"><a href="#动态代理的实现" class="headerlink" title="动态代理的实现"></a>动态代理的实现</h4><p>JDK动态代理是通过实现接口的方式来实现的，也就是我们需要一个接口，抽象对外的动作</p><p>JDK动态代理主要涉及两个类：java.lang.reflect.Proxy 和 java.lang.reflect.InvocationHandler。</p><p>这里我们依旧是对刚才的OrderServiceImpl做代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceDynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被代理的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object proxyTarget;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderServiceDynamicProxy</span><span class="params">(Object proxyTarget)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.proxyTarget = proxyTarget;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到代理对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = proxyTarget.getClass();</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(targetClass.getClassLoader(), targetClass.getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        beforeMethod(args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行代理的方法</span></span><br><span class="line">        Object returnResult = method.invoke(<span class="keyword">this</span>.proxyTarget, args);</span><br><span class="line"></span><br><span class="line">        afterMethod(returnResult);</span><br><span class="line">        <span class="keyword">return</span> returnResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">beforeMethod</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object arg : args) &#123;</span><br><span class="line">            System.out.println(<span class="string">"代理方法的参数   "</span> + arg.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"动态代理 before code"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">afterMethod</span><span class="params">(Object returnResult)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"得到代理方法返回之后的结果   "</span> + returnResult.toString());</span><br><span class="line">        System.out.println(<span class="string">"动态代理 after code"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试方法</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dynamicProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Order order = <span class="keyword">new</span> Order();</span><br><span class="line">    order.setUserId(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    OrderService orderServiceDynamicProxy =</span><br><span class="line">        (OrderService) <span class="keyword">new</span> OrderServiceDynamicProxy(<span class="keyword">new</span> OrderServiceImpl()).getProxyObject();</span><br><span class="line">    orderServiceDynamicProxy.saveOrder(order);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=====结果=====</span><br><span class="line">代理方法的参数   Order&#123;orderInfo=<span class="keyword">null</span>, userId=<span class="number">2</span>&#125;</span><br><span class="line">动态代理 before code</span><br><span class="line">Service层调用Dao层添加Order</span><br><span class="line">得到代理方法返回之后的结果   <span class="number">1</span></span><br><span class="line">动态代理 after code</span><br></pre></td></tr></table></figure><p>每一个动态代理类都必须要实现InvocationHandler这个接口，并实现其中的invoke方法，并且每个代理类的实例都关联到了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的invoke 方法来进行调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span></span><br></pre></td></tr></table></figure><p>invoke的三个参数</p><p>proxy：所代理的那个真实对象</p><p>method：所要调用真实对象的某个方法的Method对象</p><p>args：调用真实对象某个方法时接受的参数</p><p>然后就是Proxy这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，但是我们用的最多的就是 newProxyInstance 这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></span></span><br></pre></td></tr></table></figure><p>newProxyInstance的三个参数</p><p>loader：一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载【ClassLoader即类加载器，用来加载类到内存中】</p><p>interfaces：一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了。也就是抽象角色，其中有着对外提供的方法。</p><p>h：一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上</p><h4 id="动态代理的过程"><a href="#动态代理的过程" class="headerlink" title="动态代理的过程"></a>动态代理的过程</h4><ol><li>拿到被代理的对象的引用，并且去得到它的所有接口，反射获取</li><li>JDK Proxy重新生成一个新的类，同时新的类的实现被代理类的所有实现</li><li>动态生成Java代码，把新加的业务逻辑方法由一定的逻辑代码去调用</li><li>编译新生成的Java代码.class</li><li>再重新加载到JVM中运行</li></ol><p>这上面的过程就是字节码的重组</p><h4 id="JDK动态代理为什么不能通过继承实现？"><a href="#JDK动态代理为什么不能通过继承实现？" class="headerlink" title="JDK动态代理为什么不能通过继承实现？"></a>JDK动态代理为什么不能通过继承实现？</h4><p>这里我们只需要把上面动态代理过程中第四步中心编译新生成的Java代码取出研究一下就知道了</p><p>将JDK动态代理生成的class文件保存到本地，只需要加上一行代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.getProperties().put(<span class="string">"jdk.proxy.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br><span class="line"></span><br><span class="line">可以双击Shift去查找ProxyGenerator，可以看到该类在java.lang.reflect中</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> saveGeneratedFiles = (Boolean)AccessController.doPrivileged(<span class="keyword">new</span> GetBooleanAction(<span class="string">"jdk.proxy.ProxyGenerator.saveGeneratedFiles"</span>));</span><br></pre></td></tr></table></figure><p>但是需要注意这是新版的JDK的写法，我这边是JDK11.0.6。如果是低版本的JDK，如果JDK8，则是下面的这种写法。</p><p>还有这行代码是需要写在main方法中的，如果在Junit的Test方法中则调用无法生成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.getProperties().put(<span class="string">""</span>sun.misc.ProxyGenerator.saveGeneratedFiles<span class="string">", "</span><span class="keyword">true</span><span class="string">");</span></span><br></pre></td></tr></table></figure><p>最后得到相应的代理$Proxy0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里便是代理的我们的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">saveOrder</span><span class="params">(Order var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">"com.april.proxy.OrderService"</span>).getMethod(<span class="string">"saveOrder"</span>, Class.forName(<span class="string">"com.april.proxy.Order"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到自动生成的代理类是已经继承了Proxy类的，由于Java是单继承的，所以</p><hr><h3 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h3><p>CGLIB是一个强大、高性能的字节码生成库，它用于在运行时扩展Java类和实现接口；本质上它是通过动态的生成一个子类去覆盖所要代理的类（非final修饰的类和方法），所以CGLib动态代理是通过继承实现的。Enhancer是一个非常重要的类，它允许为非接口类型创建一个JAVA代理，Enhancer动态的创建给定类的子类并且拦截代理类的所有的方法，和JDK动态代理不一样的是不管是接口还是类它都能正常工作。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p><p>这里接着对上面的OrderServiceImpl进行代理，此时可以不需要OrderService接口了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * <span class="meta">@author</span> AprilViolet</span><br><span class="line"> * <span class="meta">@version</span> V1.0.0</span><br><span class="line"> * <span class="meta">@projectName</span> GitFlowDemo</span><br><span class="line"> * <span class="meta">@description</span> 实现代理的类</span><br><span class="line"> * <span class="meta">@date</span> <span class="number">2020.01</span>.27 星期一 <span class="number">22</span>:<span class="number">00</span></span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 真实的被代理的类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">createProxy</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 设置代理目标</span></span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.object.getClass());</span><br><span class="line">        <span class="comment">// 设置单一回调回调，在调用中拦截目标方法的调用</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 设置类加载器</span></span><br><span class="line">        enhancer.setClassLoader(<span class="keyword">this</span>.object.getClass().getClassLoader());</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当对基于代理的方法回调时，在调用原方法之前会调用该方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object      代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method      拦截的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args        拦截的方法的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 代理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object object, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        Object result = methodProxy.invokeSuper(object, args);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before method invoke..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after method invoke..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cglibProxyTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    OrderServiceImpl orderService = <span class="keyword">new</span> OrderServiceImpl();</span><br><span class="line">    OrderServiceImpl proxy = (OrderServiceImpl) <span class="keyword">new</span> CglibProxy().createProxy(orderService);</span><br><span class="line">    proxy.saveOrder(<span class="keyword">new</span> Order());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=====结果=====</span><br><span class="line">before method invoke...</span><br><span class="line">Service层调用Dao层添加Order</span><br><span class="line">after method invoke...</span><br></pre></td></tr></table></figure><p>详细的CGlib使用可以参考 <a href="https://blog.csdn.net/yaomingyang/article/details/82762697">参考一</a></p><p>动态代理的原理图</p><p><img src="https://s2.ax1x.com/2020/01/28/1MPW0x.md.png" alt="动态代理的原理图"><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p><p><strong><em>如有错误，欢迎留言指正！</em></strong></p><p>​                                                      二〇二〇年一月二十八日 星期二 20:38</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://blog.csdn.net/yaomingyang/article/details/82762697">参考一</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://www.cnblogs.com/wyq1995/p/10945034.html">参考二</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      结构性、代理模式
    
    </summary>
    
    
      <category term="Java" scheme="http://aprilviolet.github.io/categories/Java/"/>
    
      <category term="设计模式" scheme="http://aprilviolet.github.io/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://aprilviolet.github.io/tags/Java/"/>
    
      <category term="设计模式" scheme="http://aprilviolet.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>常用的设计模式总结（三）</title>
    <link href="http://aprilviolet.github.io/article/2019.12/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://aprilviolet.github.io/article/2019.12/常用的设计模式总结（三）/</id>
    <published>2019-12-22T02:55:47.000Z</published>
    <updated>2020-01-28T12:08:31.106Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>作用：工厂模式主要实现了创建和和调用者的分离</p><h1 id="工厂模式的分类"><a href="#工厂模式的分类" class="headerlink" title="工厂模式的分类"></a>工厂模式的分类</h1><ul><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li></ul><a id="more"></a><h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>简单工厂模式主要是由抽象的产品公共接口、具体的产品，生产产品的工厂组成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractVideo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产课程的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoVideo</span> <span class="keyword">extends</span> <span class="title">AbstractVideo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"录制Go课程视频"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVideo</span> <span class="keyword">extends</span> <span class="title">AbstractVideo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"录制Java课程视频"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractVideo <span class="title">getVideo</span><span class="params">(String videoName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 封装主要的生产逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"java"</span>.equals(videoName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JavaVideo();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"go"</span>.equals(videoName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GoVideo();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/12/22/QxrQ7d.jpg" alt="简单工厂模式 UML"></p><p>但是简单工厂模式违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。</p><hr><h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p>工厂方法模式通过定义一个抽象工厂，将类的实例化延迟到抽象工厂的子类中完成，即由子类来决定应该创建哪一个类。</p><p>相较于简单工厂主要增加了抽象工厂这个抽象类，将具体的创建对象交给不同的工厂工厂的子类去完成，然后在得到工厂的时候就可以选择不同的工厂类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractVideoFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到课程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 课程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> AbstractVideo <span class="title">getVideo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoVideoFactory</span> <span class="keyword">extends</span> <span class="title">AbstractVideoFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">AbstractVideo <span class="title">getVideo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GoVideo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryMethodTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">factoryMethodTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AbstractVideoFactory videoFactory1 = <span class="keyword">new</span> JavaVideoFactory();</span><br><span class="line">        AbstractVideoFactory videoFactory2 = <span class="keyword">new</span> GoVideoFactory();</span><br><span class="line">        videoFactory1.getVideo().produce();</span><br><span class="line">        videoFactory2.getVideo().produce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/12/22/QxsdxK.jpg" alt="工厂方法模式 UML"></p><p>但是这种方式就增加了系统的复杂度：类的个数将成对增加。</p><hr><h1 id="抽象工厂模式1"><a href="#抽象工厂模式1" class="headerlink" title="抽象工厂模式1"></a>抽象工厂模式<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h1><p>抽象工厂模式是工厂方法模式的升级版本，它用来创建一组相关或者相互依赖的对象。</p><p>它与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。</p><p>在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。</p><p>在抽象工厂模式中，有一个产品族的概念：所谓的产品族，是指位于不同产品等级结构中功能相关联的产品组成的家族。抽象工厂模式所提供的一系列产品就组成一个产品族；而工厂方法提供的一系列产品称为一个等级结构。</p><p>如果工厂的产品全部属于同一个等级结构，则属于工厂方法模式；如果工厂的产品来自多个等级结构，则属于抽象工厂模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractArticle</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产视频文章</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractVideo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产视频</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaArticle</span> <span class="keyword">extends</span> <span class="title">AbstractArticle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"编写Java课程手记"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVideo</span> <span class="keyword">extends</span> <span class="title">AbstractVideo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"录制Java课程视频"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CourseFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">AbstractVideo <span class="title">getVideo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">AbstractArticle <span class="title">getArticle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaCourseFactory</span> <span class="keyword">implements</span> <span class="title">CourseFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractVideo <span class="title">getVideo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JavaVideo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractArticle <span class="title">getArticle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JavaArticle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abstractFactoryTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CourseFactory courseFactory = <span class="keyword">new</span> JavaCourseFactory();</span><br><span class="line">        courseFactory.getVideo().produce();</span><br><span class="line">        courseFactory.getArticle().produce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/12/22/Qx6I4s.jpg" alt="抽象工厂模式 UML"></p><h2 id="抽象工厂模式的优点"><a href="#抽象工厂模式的优点" class="headerlink" title="抽象工厂模式的优点"></a>抽象工厂模式的优点</h2><p>抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是可以在类的内部对产品族进行约束。所谓的产品族，一般或多或少地都存在一定的关联，抽象工厂模式就可以在类内部对产品族的关联关系进行定义和描述，而不必专门引入一个新的类来进行管理。</p><h2 id="抽象工厂模式的缺点"><a href="#抽象工厂模式的缺点" class="headerlink" title="抽象工厂模式的缺点"></a>抽象工厂模式的缺点</h2><p>产品族的扩展将是一件十分费力的事情，假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。所以使用抽象工厂模式时，对产品等级结构的划分是非常重要的。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。说得更明白一点，就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。假如各个等级结构中的实现类之间不存在关联或约束，则使用多个独立的工厂来对产品进行创建，则更合适一点。</p><p><strong><em>如有错误，欢迎留言指正！</em></strong></p><p>​                                                      二〇一九年十二月十三日 星期五 12:38</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://www.cnblogs.com/zailushang1996/p/8601808.html">博客园 java 三种工厂模式</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      创建型、工厂模式
    
    </summary>
    
    
      <category term="Java" scheme="http://aprilviolet.github.io/categories/Java/"/>
    
      <category term="设计模式" scheme="http://aprilviolet.github.io/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://aprilviolet.github.io/tags/Java/"/>
    
      <category term="设计模式" scheme="http://aprilviolet.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>常用的设计模式总结(二)</title>
    <link href="http://aprilviolet.github.io/article/2019.12/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://aprilviolet.github.io/article/2019.12/常用的设计模式总结（二）/</id>
    <published>2019-12-19T13:54:34.000Z</published>
    <updated>2020-01-28T12:08:26.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建型模式之单例模式"><a href="#创建型模式之单例模式" class="headerlink" title="创建型模式之单例模式"></a>创建型模式之单例模式</h1><h2 id="单例模式的概念"><a href="#单例模式的概念" class="headerlink" title="单例模式的概念"></a>单例模式的概念</h2><p>单例模式值该类只有一个实例，且该类能够自行创建供其它类使用。</p><p>主要解决一个全局使用的类频繁的创建与销毁，该模式可以减少了系统性能的开销。</p><a id="more"></a><h2 id="单例模式的分类"><a href="#单例模式的分类" class="headerlink" title="单例模式的分类"></a>单例模式的分类</h2><ul><li>懒汉式：线程不安全，调用效率高，但是不能延迟加载</li><li>饿汉式：线程安全，调用效率不高，但是可以延迟加载</li><li>双重检测锁：线程不安全（由于JVM底层内部模型的指令重排）</li><li>静态内部类：线程安全，调用效率高，并且可以延迟加载</li><li>枚举单例：线程安全，调用效率高，但是不能延迟加载</li></ul><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>懒汉式是类初始化的时候不立即加载这个对象，当需要的时候再加载。</p><p>无论那种单例模式首先的第一步就是将该类的构造方法私有化！</p><p>懒汉式需要注意的是需要加上synchronized关键字，如果不加上synchronized关键字，在多线程下会有存在不是单例的情况！</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到singleton的对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 单例的LazySingleton</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还是解释一下如果不加上synchronized会造成不安全的原因：</p><p>首先假设有两个线程同时运行，此时第一个线程先调用<em>LazySingleton.getInstance</em>方法得到对象，此时先行判断instance是否为null，此时还没有执行到<em>instance = new LazySingleton();</em>所以可以进入if语句。但是此时可能第一个线程停住了，由第二个线程开始执行<em>LazySingleton.getInstance</em>，同样的进入了先判断instance是否为null，此时第一个线程并未执行到初始化对象的那一句，所以instance任然为null，依旧会进入if语句。所以会打破单例。如果加上synchronized，则第一个线程进入getInstance方法，即使轮询到其它线程执行，其它线程也执行不了getInstance方法，只有等到第一个线程的getInstance方法执行完成得到对象其它线程才可以执行。</p><p>想要试验的，可以在idea中打上Thread的类型的断电去调试一下。</p><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>类初始化时立即加载这个对象，此时单例的对象可以申明final的</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton INSTANCE = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回单例对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回单例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双重检测锁"><a href="#双重检测锁" class="headerlink" title="双重检测锁"></a>双重检测锁</h2><p>双重检测锁也可以产生单例对象，但是由于JVM底层内部模型的原因，指令重排，线程不安全，偶尔会出现问题，不建议使用。</p><p>指令重排是针对的实例化对象的那行代码，实际上可以分为三个步骤</p><ol><li>分配内存给这个对象</li><li>初始化对象</li><li>设置lazyDoubleCheckSingleton 指向刚分配的内存地址</li></ol><p>但是有些编译器为了性能的原因，可能会将第二步和第三步进行<strong>重排序</strong>，顺序就成了：</p><ol><li>分配内存给这个对象</li><li>设置lazyDoubleCheckSingleton 指向刚分配的内存地址</li><li>初始化对象</li></ol><p>此时如果是多线程的情况下，仍然有可能发生第一个线程执行完成了1，2步骤也就是分配内存和指向刚分配的内存地址，此时没有初始化这个对象，所以此时这个对象仍然为null，所以第二个线程仍然可能进入方法，返回不同的对象。</p><p>要解决双重检测锁的方法是给返回的单例对象加上volatile关键字</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyDoubleCheckSingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里加上volatile关键字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyDoubleCheckSingleton lazyDoubleCheckSingleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyDoubleCheckSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyDoubleCheckSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazyDoubleCheckSingleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyDoubleCheckSingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lazyDoubleCheckSingleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在单线程中，这里是允许进行指令重排序的</span></span><br><span class="line">                    <span class="comment">// 1.分配内存给这个对象</span></span><br><span class="line">                    <span class="comment">// 2.初始化对象</span></span><br><span class="line">                    <span class="comment">// 3.设置lazyDoubleCheckSingleton 指向刚分配的内存地址</span></span><br><span class="line">                    <span class="comment">// 这里的2和3是有可能指令重排的</span></span><br><span class="line">                    lazyDoubleCheckSingleton = <span class="keyword">new</span> LazyDoubleCheckSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lazyDoubleCheckSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClassSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> StaticInnerClassSingleton staticInnerClassSingleton = <span class="keyword">new</span> StaticInnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClassSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClassSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.staticInnerClassSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSigletonUser</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EnumSigletonUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span>  SingletonUser &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建一个枚举对象，该对象天生为单例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> EnumSigletonUser enumSigletonUser;</span><br><span class="line"></span><br><span class="line">        SingletonUser() &#123;</span><br><span class="line">            <span class="keyword">this</span>.enumSigletonUser = <span class="keyword">new</span> EnumSigletonUser();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> EnumSigletonUser <span class="title">getSingletonUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> enumSigletonUser;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到User单例</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ser单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumSigletonUser <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonUser.INSTANCE.getSingletonUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="破坏单例"><a href="#破坏单例" class="headerlink" title="破坏单例"></a>破坏单例</h2><p>如果只是简单的使用，上面的单例代码是没有问题的。但是想要保证安全性，那么需要了解一下如果破坏单例，才能够去方式破坏。</p><ul><li><strong>通过序列化破坏代理</strong></li></ul><p>下面的代码是使用序列化的方式进行破坏单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroySingletonBySerializationTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>&#123;</span><br><span class="line">    HungrySingleton instance = HungrySingleton.getInstance();</span><br><span class="line">    ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"F:\\singletonFile"</span>));</span><br><span class="line">    objectOutputStream.writeObject(instance);</span><br><span class="line"></span><br><span class="line">    ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"F:\\singletonFile"</span>));</span><br><span class="line">    HungrySingleton hungrySingleton = (HungrySingleton) objectInputStream.readObject();</span><br><span class="line"></span><br><span class="line">    System.out.println(instance);</span><br><span class="line">    System.out.println(hungrySingleton);</span><br><span class="line">    System.out.println(instance == hungrySingleton);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何解决呢？方式是给单例的类加上一个readResolve方法，返回单例的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 解决序列化破坏单例</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 返回单例对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>通过反射攻击单例模式</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroySingletonByReflectionTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class hungryClass = HungrySingleton.class;</span><br><span class="line">    Constructor constructor = hungryClass.getDeclaredConstructor();</span><br><span class="line">    <span class="comment">// 强制修改单例类构造方法的修饰符为public</span></span><br><span class="line">    constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    HungrySingleton hungrySingleton = HungrySingleton.getInstance();</span><br><span class="line">    HungrySingleton reflexHungrySingleton = ((HungrySingleton) constructor.newInstance());</span><br><span class="line"></span><br><span class="line">    System.out.println(hungrySingleton);</span><br><span class="line">    System.out.println(reflexHungrySingleton);</span><br><span class="line">    System.out.println(hungrySingleton == reflexHungrySingleton);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何解决呢？对于饿汉式和静态内部类式，可以在私有的构造方法中进行判断当前的对象是否为null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 反射防御的代码</span></span><br><span class="line">    <span class="comment">// 对于饿汉式和静态内部类式这种是有效的，其它的方式是无法避免反射攻击的</span></span><br><span class="line">    <span class="keyword">if</span> (HUNGRY_SINGLETON != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"禁止使用反射破坏单例!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反射进行攻击，对于懒汉式来说，下面这两行代码如果颠倒顺序，那么就会出现不同的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HungrySingleton reflexHungrySingleton = ((HungrySingleton) constructor.newInstance());</span><br><span class="line">HungrySingleton hungrySingleton = HungrySingleton.getInstance();</span><br></pre></td></tr></table></figure><p>如果是先反射构造单例，再通过单例类得到单例对象，那么在构造方法中判断null是有效的</p><p>但是如果是先得到单例对象，然后通过反射构造单例，那么在构造方法中判断null是无效的</p><p>原因是如果先通过单例类得到单例对象，那么此时的</p><p>然而对于饿汉式和静态内部类式在构造方法中进行判断当前的对象是否为null是有效的，无论两者的顺序是否不同，那是因为饿汉式和静态内部类是不能延迟加载，也即是在类初始化的时候就已经得到单例对象了。</p><p><strong>枚举单例既可以防止序列化破坏也可以防止反射攻击。</strong></p><p><strong><em>如有错误，欢迎留言指正！</em></strong></p><p>​                                                     二〇一九年十二月二十一日 星期六 17:50</p>]]></content>
    
    <summary type="html">
    
      创建型、单例模式
    
    </summary>
    
    
      <category term="Java" scheme="http://aprilviolet.github.io/categories/Java/"/>
    
      <category term="设计模式" scheme="http://aprilviolet.github.io/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://aprilviolet.github.io/tags/Java/"/>
    
      <category term="设计模式" scheme="http://aprilviolet.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>常用的设计模式总结(一)</title>
    <link href="http://aprilviolet.github.io/article/2019.12/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://aprilviolet.github.io/article/2019.12/常用的设计模式总结（一）/</id>
    <published>2019-12-11T09:25:00.000Z</published>
    <updated>2020-05-31T01:45:47.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用的设计模式总结-一"><a href="#常用的设计模式总结-一" class="headerlink" title="常用的设计模式总结(一)"></a>常用的设计模式总结(一)</h1><h2 id="设计模式的目的"><a href="#设计模式的目的" class="headerlink" title="设计模式的目的"></a>设计模式的目的</h2><p>设计模式的目的是为了让程序，具有更好的代码重用性、可读性（编程规范性，便于后期维护和理解）、可扩展性（当需要增加新需求时，非常方便）、可靠性（增加新功能后，对原功能会有影响）、使程序呈现高内聚，低耦合的特性。设计模式包含了面向对象的精髓，“懂了设计模式，就懂得了面向对象分析和设计（OOA/D）的核心”。</p><a id="more"></a><p>虽说在平时开发简单的CRUD的时候可能用到的设计模式并不多，但是如果代码需要重构，需要优化，或者自己去设计一个项目的时候设计模式还是非常重要的！掌握一些常用的设计模式也是非常必要的！</p><hr><h2 id="简单的介绍"><a href="#简单的介绍" class="headerlink" title="简单的介绍"></a>简单的介绍</h2><h3 id="设计模式的七大原则12"><a href="#设计模式的七大原则12" class="headerlink" title="设计模式的七大原则12"></a>设计模式的七大原则<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></h3><ul><li>开闭原则：一个软件实体如类、模块和函数应该对扩展开放（提供方）、对修改关闭（使用方）<ul><li>开闭原则的作用就是在不修改软件源代码的前提下，可以扩展模块的功能。这里的不修改软件源代码指的是不修改已经写好的代码。</li><li>开闭原则的实现方法可以通过“抽象约束、封装变化”来实现，即通过设计合理的接口或者抽象类来为软件实体定义一个相对稳定的抽象层，而将可变因素封装在具体实现类中。因此抽象的设计就变得尤为重要，只要抽象的合理，就可以基本保持架构的稳定，而软件中异变的细节可以从抽象派生出来的实现类来进行扩展。当软件需求发生改变时候，只需要重新派生一个实现类就可以来实现扩展了。</li></ul></li><li>里氏替换原则：所有引用基类的地方必须能透明地使用其子类的对象，子类可以扩展父类的功能，但不能改变父类原有的功能。<ul><li>里氏替换原则通俗来讲就是子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。如果通过重写父类的方法来完成新功能，这样写虽然简单，但是整个继承体系的可复用性较差，特别是使用多态的时候，容易出现问题。</li><li>企鹅、鸵鸟和几维鸟从生物学的角度来划分，它们属于鸟类，但是它们并不能飞翔。所以从类的继承关系来看，它们不能继承“鸟”的飞这个方法并去重写“飞”这个方法，所以它们不能定义成“鸟”的子类。</li></ul></li><li>单一职责原则：单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分<ul><li>单一职责从名字来看就已经很明了了，一个类、接口和方法只负责一项职责，这样可以降低类的复杂度，提供系统的可维护性。如果单一职责原则遵循得好，当修改一个功能时，可以显著降低对其他功能的影响。</li><li>接口和方法必须是单一职责，而类的单一职责视情况而定。</li></ul></li><li>接口隔离原则：客户端不应该依赖它不需要的接口类，类之间的依赖关系应该建立在最小的接口上<ul><li>一句话，就是实现接口的类中，有多余的方法时，需要将接口进行拆分。接口尽量小，但是要有限度，一个接口只服务于一个子模块或业务逻辑。</li></ul></li><li>依赖倒置原则：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象<ul><li>其核心思想是：要面向接口、抽象编程，不要面向实现编程，这样就降低了客户与实现模块间的耦合。</li><li>依赖倒置原则的实现需要注意的是每个类尽量提供接口或者抽象类，或者两者都具备。变量的声明类型尽量是接口或者抽象类。任何类都不应该从具体类派生。使用继承时尽量遵循里氏替换原则</li></ul></li><li>迪米特法则：又叫最少知道原则，一个软件实体应尽可能少地与其他实体发生相互作用<ul><li>迪米特法则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块独立，相互之间不存在（或很少有）依赖关系。迪米特法则不希望类之间建立直接的关系。如果真的有需要建立联系，也希望能通过它的中间类来转达。</li><li>迪米特法则的实现可以从两个角度来看<ul><li>从依赖者的角度来看，只依赖应该依赖的对象</li><li>从被依赖者的角度来看，只暴露应该暴露的方法</li></ul></li></ul></li><li>合成复用原则：在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现<ul><li>如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。</li><li>通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点：<ul><li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</li><li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li><li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li></ul></li><li>合成复用原则的实现是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。</li></ul></li></ul><hr><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><h3 id="根据目的、用途不同分为三大类：创建型、结构型、行为型"><a href="#根据目的、用途不同分为三大类：创建型、结构型、行为型" class="headerlink" title="根据目的、用途不同分为三大类：创建型、结构型、行为型"></a>根据目的、用途不同分为三大类：创建型、结构型、行为型</h3><ul><li>创建型：创建型模式提供了一种在创建对象的同时隐藏创建逻辑的方式。主要特点是将对象的创建与使用分离，使得这些程序在判断针对某个给定实例需要创建哪些对象时更加灵活，这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，只需要使用对象即可。<ul><li><strong>单例模式</strong><ul><li>懒汉式</li><li>饿汉式</li><li>双重检测锁</li><li>静态内部类</li><li>枚举单例</li></ul></li><li><strong>工厂模式</strong><ul><li>简单工厂</li><li>工厂方法（类创建模式）</li><li>抽象工厂</li></ul></li><li><strong>建造者模式</strong></li><li><strong>原型模式</strong></li></ul></li><li>结构型：结构性关注类和对象的组合，描述的是如何将类与对象按某种布局组成更大的结构。<ul><li><strong>适配器模式</strong>（类结构型模式和对象结构型模式）</li><li><strong>代理模式</strong></li><li><strong>装饰模式</strong></li><li><strong>外观模式</strong></li><li>享元模式</li><li>桥接模式</li><li>组合模式</li></ul></li><li>行为型：行为型用于描述程序在运行时复杂的流程控制，或者说多个对象之间的通信。即描述多个类或对象之间怎样相互协作共同完成单个对象无法完成的任务。<ul><li><strong>责任链模式</strong></li><li><strong>策略模式</strong></li><li><strong>模板方法</strong>（类行为型模式）</li><li><strong>状态模式</strong></li><li>迭代器模式</li><li>中介者模式</li><li>命令模式</li><li>解释器模式（类行为型模式）</li><li>访问者模式</li><li>观察者模式</li><li>备忘录模式</li></ul></li></ul><h3 id="根据处理范围不同，设计模式又可分为类模式和对象模式"><a href="#根据处理范围不同，设计模式又可分为类模式和对象模式" class="headerlink" title="根据处理范围不同，设计模式又可分为类模式和对象模式"></a>根据处理范围不同，设计模式又可分为类模式和对象模式</h3><p>类模式处理类与子类的关系，通过处理这些关系来建立继承，属于静态关系，在编译时候确定下来。</p><p>对象模式处理对象之间的关系，运行时发生变化，属于动态关系。</p><p><strong>注：</strong>在上面中的设计模式除了特别标注的是类模式，其它的都是对象模式</p><hr><p>上面设计模式中加粗的是比较常用并且重要的，需要特别记住，在各种框架中都有运用，用到的时候希望可以能够记起来并且灵活运用。需要记住的是，有时候设计模式不是绝对的！</p><p><strong><em>如有错误，欢迎留言指正！</em></strong></p><p>​                                                      二〇一九年十二月十三日 星期五 12:38</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="http://c.biancheng.net/design_pattern/">C语言中文网 设计模式</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://blog.csdn.net/zhengzhaoyang122/article/details/95240869">CSDN 设计模式-七大原则</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      总结常用的几种设计模式
    
    </summary>
    
    
      <category term="Java" scheme="http://aprilviolet.github.io/categories/Java/"/>
    
      <category term="设计模式" scheme="http://aprilviolet.github.io/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://aprilviolet.github.io/tags/Java/"/>
    
      <category term="设计模式" scheme="http://aprilviolet.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>想说的话</title>
    <link href="http://aprilviolet.github.io/article/2019.12/%E4%B8%87%E7%89%A9%E4%B9%8B%E5%A7%8B/"/>
    <id>http://aprilviolet.github.io/article/2019.12/万物之始/</id>
    <published>2019-11-02T14:04:50.000Z</published>
    <updated>2020-05-30T12:34:47.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="想说的一些话"><a href="#想说的一些话" class="headerlink" title="想说的一些话"></a>想说的一些话</h1><p>最初就一直想有一个可以记录学习历程的地方，虽然自己也都有记笔记，但是总想着能够放在网上，分享出去。听过这样的一句话：把你学到的知识，用你自己的、最简单的话，讲给一个外行、一个小孩子听，如果这些人都听懂了，那你就真的懂了。</p><a id="more"></a><p>可是在如今信息爆炸的时代，网上的各种文章满天飞，有技术精湛的，有满篇幅转载抄袭的，各种文章看的眼花缭乱，重复性文章更是多如牛毛，我还是不要去掺和为好。</p><p>这里是我个人知识生活的一个记录，希望以后回想起来能有个念想。毕竟头脑不太好，能记住的东西有限，还是写下来更为妥当。</p><p>死亡并不可怕，等死才可怕。学习并不胆怯，无知才恐慌。学习的越多，才会发现越多没有学。</p><p>越往后学习，就会越来越发现人的强大，知识的丰富，个人的渺小。就越会对未知产生恐慌，就越会盲目的学习。这就是我目前害怕的地方。</p><p>你要知道什么时候自己知道，什么时候自己不知道，什么是自己知道的，什么是自己不知道的，要非常小心，不要自己把自己给骗了</p><hr><h1 id="感慨"><a href="#感慨" class="headerlink" title="感慨"></a>感慨</h1><blockquote><p>活着是一种修行！</p></blockquote><blockquote><p>时过境迁物是人非，本是过客，何必千千情结！</p></blockquote><blockquote><p>不要对社会的不公平太惆怅，这个世界本来就不是公平的。</p></blockquote><blockquote><p>看待事情的时候从对立面考虑一下或许另有一番景色。</p></blockquote><blockquote><p>道理大都是长大了才懂，我们大多数人都只是一个平凡人，一个普通人。但是也不要去轻易否定自己，同时不要将自己是一个平凡人作为接口而不去努力，切记！</p></blockquote><p>​                                                     二〇一九年十一月二十日 星期三 18:57</p>]]></content>
    
    <summary type="html">
    
      第一篇文章
    
    </summary>
    
    
      <category term="生活" scheme="http://aprilviolet.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="博客" scheme="http://aprilviolet.github.io/categories/%E7%94%9F%E6%B4%BB/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="生活" scheme="http://aprilviolet.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
</feed>
