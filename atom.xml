<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>听到涛声</title>
  
  <subtitle>起风了，唯有努力生存！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://aprilviolet.github.io/"/>
  <updated>2019-12-14T04:12:38.991Z</updated>
  <id>http://aprilviolet.github.io/</id>
  
  <author>
    <name>AprilViolet</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常用的设计模式总结(一)</title>
    <link href="http://aprilviolet.github.io/2019/12/11/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93(%E4%B8%80)/"/>
    <id>http://aprilviolet.github.io/2019/12/11/常用的设计模式总结(一)/</id>
    <published>2019-12-11T09:25:00.000Z</published>
    <updated>2019-12-14T04:12:38.991Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用的设计模式总结"><a href="#常用的设计模式总结" class="headerlink" title="常用的设计模式总结"></a>常用的设计模式总结</h1><h2 id="设计模式的目的"><a href="#设计模式的目的" class="headerlink" title="设计模式的目的"></a>设计模式的目的</h2><p>设计模式的目的是为了让程序，具有更好的代码重用性、可读性（编程规范性，便于后期维护和理解）、可扩展性（当需要增加新需求时，非常方便）、可靠性（增加新功能后，对原功能会有影响）、使程序呈现高内聚，低耦合的特性。设计模式包含了面向对象的精髓，“懂了设计模式，就懂得了面向对象分析和设计（OOA/D）的核心”。</p><p>虽说在平时开发简单的CRUD的时候可能用到的设计模式并不多，但是如果代码需要重构，需要优化，或者自己去设计一个项目的时候设计模式还是非常重要的！掌握一些常用的设计模式也是非常必要的！</p><a id="more"></a><hr><h2 id="简单的介绍"><a href="#简单的介绍" class="headerlink" title="简单的介绍"></a>简单的介绍</h2><h3 id="设计模式的七大原则12"><a href="#设计模式的七大原则12" class="headerlink" title="设计模式的七大原则12"></a>设计模式的七大原则<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></h3><ul><li>开闭原则：一个软件实体如类、模块和函数应该对扩展开放（提供方）、对修改关闭（使用方）<ul><li>开闭原则的作用就是在不修改软件源代码的前提下，可以扩展模块的功能。这里的不修改软件源代码指的是不修改已经写好的代码。</li><li>开闭原则的实现方法可以通过“抽象约束、封装变化”来实现，即通过设计合理的接口或者抽象类来为软件实体定义一个相对稳定的抽象层，而将可变因素封装在具体实现类中。因此抽象的设计就变得尤为重要，只要抽象的合理，就可以基本保持架构的稳定，而软件中异变的细节可以从抽象派生出来的实现类来进行扩展。当软件需求发生改变时候，只需要重新派生一个实现类就可以来实现扩展了。</li></ul></li><li>里氏替换原则：所有引用基类的地方必须能透明地使用其子类的对象，子类可以扩展父类的功能，但不能改变父类原有的功能。<ul><li>里氏替换原则通俗来讲就是子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。如果通过重写父类的方法来完成新功能，这样写虽然简单，但是整个继承体系的可复用性较差，特别是使用多态的时候，容易出现问题。</li><li>企鹅、鸵鸟和几维鸟从生物学的角度来划分，它们属于鸟类，但是它们并不能飞翔。所以从类的继承关系来看，它们不能继承“鸟”的飞这个方法并去重写“飞”这个方法，所以它们不能定义成“鸟”的子类。</li></ul></li><li>单一职责原则：单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分<ul><li>单一职责从名字来看就已经很明了了，一个类、接口和方法只负责一项职责，这样可以降低类的复杂度，提供系统的可维护性。如果单一职责原则遵循得好，当修改一个功能时，可以显著降低对其他功能的影响。</li><li>接口和方法必须是单一职责，而类的单一职责视情况而定。</li></ul></li><li>接口隔离原则：客户端不应该依赖它不需要的接口类，类之间的依赖关系应该建立在最小的接口上<ul><li>一句话，就是实现接口的类中，有多余的方法时，需要将接口进行拆分。接口尽量小，但是要有限度，一个接口只服务于一个子模块或业务逻辑。</li></ul></li><li>依赖倒置原则：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象<ul><li>其核心思想是：要面向接口、抽象编程，不要面向实现编程，这样就降低了客户与实现模块间的耦合。</li><li>依赖倒置原则的实现需要注意的是每个类尽量提供接口或者抽象类，或者两者都具备。变量的声明类型尽量是接口或者抽象类。任何类都不应该从具体类派生。使用继承时尽量遵循里氏替换原则</li></ul></li><li>迪米特法则：又叫最少知道原则，一个软件实体应尽可能少地与其他实体发生相互作用<ul><li>迪米特法则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块独立，相互之间不存在（或很少有）依赖关系。迪米特法则不希望类之间建立直接的关系。如果真的有需要建立联系，也希望能通过它的中间类来转达。</li><li>迪米特法则的实现可以从两个角度来看<ul><li>从依赖者的角度来看，只依赖应该依赖的对象</li><li>从被依赖者的角度来看，只暴露应该暴露的方法</li></ul></li></ul></li><li>合成复用原则：在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现<ul><li>如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。</li><li>通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点：<ul><li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</li><li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li><li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li></ul></li><li>合成复用原则的实现是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。</li></ul></li></ul><hr><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><h3 id="根据目的、用途不同分为三大类：创建型、结构型、行为型"><a href="#根据目的、用途不同分为三大类：创建型、结构型、行为型" class="headerlink" title="根据目的、用途不同分为三大类：创建型、结构型、行为型"></a>根据目的、用途不同分为三大类：创建型、结构型、行为型</h3><ul><li>创建型：创建型模式提供了一种在创建对象的同时隐藏创建逻辑的方式。主要特点是将对象的创建与使用分离，使得这些程序在判断针对某个给定实例需要创建哪些对象时更加灵活，这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，只需要使用对象即可。<ul><li><strong>单例模式</strong><ul><li>懒汉式</li><li>饿汉式</li><li>双重检测锁</li><li>静态内部类</li><li>枚举单例</li></ul></li><li><strong>工厂模式</strong><ul><li>简单工厂</li><li>工厂方法（类创建模式）</li><li>抽象工厂</li></ul></li><li><strong>建造者模式</strong></li><li><strong>原型模式</strong></li></ul></li><li>结构型：结构性关注类和对象的组合，描述的是如何将类与对象按某种布局组成更大的结构。<ul><li><strong>适配器模式</strong>（类结构型模式和对象结构型模式）</li><li><strong>代理模式</strong></li><li><strong>装饰模式</strong></li><li><strong>外观模式</strong></li><li>享元模式</li><li>桥接模式</li><li>组合模式</li></ul></li><li>行为型：行为型用于描述程序在运行时复杂的流程控制，或者说多个对象之间的通信。即描述多个类或对象之间怎样相互协作共同完成单个对象无法完成的任务。<ul><li><strong>责任链模式</strong></li><li><strong>策略模式</strong></li><li><strong>模板方法</strong>（类行为型模式）</li><li><strong>状态模式</strong></li><li>迭代器模式</li><li>中介者模式</li><li>命令模式</li><li>解释器模式（类行为型模式）</li><li>访问者模式</li><li>观察者模式</li><li>备忘录模式</li></ul></li></ul><h3 id="根据处理范围不同，设计模式又可分为类模式和对象模式"><a href="#根据处理范围不同，设计模式又可分为类模式和对象模式" class="headerlink" title="根据处理范围不同，设计模式又可分为类模式和对象模式"></a>根据处理范围不同，设计模式又可分为类模式和对象模式</h3><p>类模式处理类与子类的关系，通过处理这些关系来建立继承，属于静态关系，在编译时候确定下来。</p><p>对象模式处理对象之间的关系，运行时发生变化，属于动态关系。</p><p><strong>注：</strong>在上面中的设计模式除了特别标注的是类模式，其它的都是对象模式</p><hr><p>上面设计模式中加粗的是比较常用并且重要的，需要特别记住，也是本次会详细记录下来的。下一篇会开始记录创建型的四种。</p><p>​                                                      二〇一九年十二月十三日 星期五 12:38</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="http://c.biancheng.net/design_pattern/" target="_blank" rel="noopener">C语言中文网 设计模式</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://blog.csdn.net/zhengzhaoyang122/article/details/95240869" target="_blank" rel="noopener">CSDN 设计模式-七大原则</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      总结常用的几种设计模式
    
    </summary>
    
    
      <category term="Java" scheme="http://aprilviolet.github.io/categories/Java/"/>
    
      <category term="设计模式" scheme="http://aprilviolet.github.io/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://aprilviolet.github.io/tags/Java/"/>
    
      <category term="设计模式" scheme="http://aprilviolet.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>万物之始</title>
    <link href="http://aprilviolet.github.io/2019/11/02/%E4%B8%87%E7%89%A9%E4%B9%8B%E5%A7%8B/"/>
    <id>http://aprilviolet.github.io/2019/11/02/万物之始/</id>
    <published>2019-11-02T14:04:50.000Z</published>
    <updated>2019-12-13T04:38:22.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="喜大普奔-博客上线"><a href="#喜大普奔-博客上线" class="headerlink" title="喜大普奔 博客上线"></a>喜大普奔 博客上线</h1><p>从大四下学期的十月底开始捣鼓这个博客，到现在也快一个月了，中途因为校招找工作耽误了许久，终于还是被我捣鼓出来了。说实在的中途也想要过放弃不弄了(≧﹏ ≦)因为中途的一些事情，但是最终还是坚持下去，把博客上线了。未来或许会经常更新或许不会经常更新，但是我一直都在，坚持就是胜利，加油，奥利给！</p><p>有任何问题您可以<a href="https://blog.csdn.net/mollen/article/details/84110708" target="_blank" rel="noopener">联系我</a></p><a id="more"></a><h1 id="想说的一些话"><a href="#想说的一些话" class="headerlink" title="想说的一些话"></a>想说的一些话</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>最初就一直想有一个可以记录学习历程的地方，虽然自己也都有记笔记，但是笔记和写博客还是有区别的。</p><p>当然我的博客也不仅仅是写一些自己的学习记录，也不仅仅是计算机编程方面的学习，也会记录一些自己的生活日常，可以说是自己的一个写日记之类的地方吧，只不过是公开出去。</p><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>道理大都是长大了才懂，我们大多数人都只是一个平凡人，一个普通人，但是也不要去轻易否定自己，不要将自己是一个平凡人作为接口而不去努力，切记！</p><p>不要对社会的不公平太惆怅，这个世界本来就不是公平的。不要对物是人非感慨太多。</p><p>看待事情的时候从对立面考虑一下或许另有一番景色。</p><p>​                                                     二〇一九年十一月二十日 星期三 18:57</p>]]></content>
    
    <summary type="html">
    
      第一篇文章
    
    </summary>
    
    
      <category term="轨迹" scheme="http://aprilviolet.github.io/categories/%E8%BD%A8%E8%BF%B9/"/>
    
      <category term="博客" scheme="http://aprilviolet.github.io/categories/%E8%BD%A8%E8%BF%B9/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="轨迹" scheme="http://aprilviolet.github.io/tags/%E8%BD%A8%E8%BF%B9/"/>
    
  </entry>
  
</feed>
