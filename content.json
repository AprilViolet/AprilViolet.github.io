{"pages":[{"title":"瞬间光影","text":"))))))","link":"/album/index.html"},{"title":"听到涛声的个人博客","text":"简介一位九零末的男生，单身孤独症患者，面向二次元编程 个人博客就是记录一些生活学习过程中琐事，博客几经周折，最后还是决定用hexo并放在Github上，省心，专注学习记录。 生活行万里路、读万卷书、听万首歌，唯有这三件事能让我惬意舒心 学习 Java开发（主要） 前端（会一些=&gt;也想要学习） Go（观望中=&gt;学习?） Android开发（观望中=&gt;学习?） 摄影修图（一直想学） 工作二零年本科毕业，目前在一家小公司从事Java开发，也算是从事自己喜欢的事业 声明有时候不得不说，在信息爆炸的时代，互联网上的知识太多了，各种抄袭真的屡见不鲜，我就不去掺和了 版权 除特别声明外，本站文章均为原创 本站原创內容 【禁止】 任何形式的：传播、转载、借鉴，谢谢！ 本站內容如有侵犯您的权益，请及时联系调整 联系 如有事情可联系:AprilEternityLT@163.com 岁月仍静好 活着是一种修行 起风了，唯有努力生存 生活本不易，流人遂自安 世间安得两全法，不负如来不负卿 男儿有胆气，仗剑走天涯 女儿有剑心，柔情满山岗 平凡的世界平凡的我做着平凡的事情过着平凡的生活 一剪闲云一溪月，一程山水一年华 一世浮生一刹那，一树菩提一烟霞 花有重开日 人无再少年 一贫如洗的真心，一事无成的温柔 往事尘烟","link":"/about/index.html"},{"title":"友链","text":"申请友链须知 - 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 - 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 - 申请链接前请先添加本博链接，请留言或者发邮件告知。 - 申请请提供：站点名称、站点链接、站点描述、logo或头像。 - 会定期清理不符合要求的友链，另行通知。 - 欢迎各位有志之士，望不吝珠玉","link":"/friend/index.html"},{"title":"留言专区","text":"如不能及时回复，您可以发邮件给我 PS：如果想要回复有头像的显示，可以去Gravatar注册并登录，回复的时候留下注册的邮箱即可。","link":"/message/index.html"},{"title":"聆听音乐","text":"&nbsp;&nbsp;静下心来，享受一下","link":"/music/index.html"}],"posts":[{"title":"常用的设计模式总结（三）","text":"工厂模式作用：工厂模式主要实现了创建和和调用者的分离 工厂模式的分类 简单工厂模式 工厂方法模式 抽象工厂模式 简单工厂模式简单工厂模式主要是由抽象的产品公共接口、具体的产品，生产产品的工厂组成的。 123456789101112131415161718192021222324252627282930313233public abstract class AbstractVideo { /** * 生产课程的 */ abstract void produce();}public class GoVideo extends AbstractVideo { @Override void produce() { System.out.println(\"录制Go课程视频\"); }}public class JavaVideo extends AbstractVideo { @Override void produce() { System.out.println(\"录制Java课程视频\"); }}public class VideoFactory { public AbstractVideo getVideo(String videoName) { // 封装主要的生产逻辑 if (\"java\".equals(videoName)) { return new JavaVideo(); } else if (\"go\".equals(videoName)) { return new GoVideo(); } return null; }} 但是简单工厂模式违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。 工厂方法模式工厂方法模式通过定义一个抽象工厂，将类的实例化延迟到抽象工厂的子类中完成，即由子类来决定应该创建哪一个类。 相较于简单工厂主要增加了抽象工厂这个抽象类，将具体的创建对象交给不同的工厂工厂的子类去完成，然后在得到工厂的时候就可以选择不同的工厂类。 12345678910111213141516171819202122232425public abstract class AbstractVideoFactory { /** * 得到课程 * * @return 课程 */ abstract AbstractVideo getVideo();}public class GoVideoFactory extends AbstractVideoFactory { @Override AbstractVideo getVideo() { return new GoVideo(); }}public class FactoryMethodTest { @Test public void factoryMethodTest() { AbstractVideoFactory videoFactory1 = new JavaVideoFactory(); AbstractVideoFactory videoFactory2 = new GoVideoFactory(); videoFactory1.getVideo().produce(); videoFactory2.getVideo().produce(); }} 但是这种方式就增加了系统的复杂度：类的个数将成对增加。 抽象工厂模式1抽象工厂模式是工厂方法模式的升级版本，它用来创建一组相关或者相互依赖的对象。 它与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。 在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。 在抽象工厂模式中，有一个产品族的概念：所谓的产品族，是指位于不同产品等级结构中功能相关联的产品组成的家族。抽象工厂模式所提供的一系列产品就组成一个产品族；而工厂方法提供的一系列产品称为一个等级结构。 如果工厂的产品全部属于同一个等级结构，则属于工厂方法模式；如果工厂的产品来自多个等级结构，则属于抽象工厂模式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public abstract class AbstractArticle { /** * 生产视频文章 */ abstract void produce();}public abstract class AbstractVideo { /** * 生产视频 */ abstract void produce();}public class JavaArticle extends AbstractArticle { @Override void produce() { System.out.println(\"编写Java课程手记\"); }}public class JavaVideo extends AbstractVideo { @Override void produce() { System.out.println(\"录制Java课程视频\"); }}public interface CourseFactory { AbstractVideo getVideo(); AbstractArticle getArticle();}public class JavaCourseFactory implements CourseFactory { @Override public AbstractVideo getVideo() { return new JavaVideo(); } @Override public AbstractArticle getArticle() { return new JavaArticle(); }}public class AbstractFactoryTest { @Test public void abstractFactoryTest() { CourseFactory courseFactory = new JavaCourseFactory(); courseFactory.getVideo().produce(); courseFactory.getArticle().produce(); }} 抽象工厂模式的优点抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是可以在类的内部对产品族进行约束。所谓的产品族，一般或多或少地都存在一定的关联，抽象工厂模式就可以在类内部对产品族的关联关系进行定义和描述，而不必专门引入一个新的类来进行管理。 抽象工厂模式的缺点产品族的扩展将是一件十分费力的事情，假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。所以使用抽象工厂模式时，对产品等级结构的划分是非常重要的。 使用场景当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。说得更明白一点，就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。假如各个等级结构中的实现类之间不存在关联或约束，则使用多个独立的工厂来对产品进行创建，则更合适一点。 如有错误，欢迎留言指正！ ​ 二〇一九年十二月十三日 星期五 12:38 1.博客园 java 三种工厂模式 ↩","link":"/article/2019.12/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/"},{"title":"想说的话","text":"想说的一些话最初就一直想有一个可以记录学习历程的地方，虽然自己也都有记笔记，但是总想着能够放在网上，分享出去。听过这样的一句话：把你学到的知识，用你自己的、最简单的话，讲给一个外行、一个小孩子听，如果这些人都听懂了，那你就真的懂了。 可是在如今信息爆炸的时代，网上的各种文章满天飞，有技术精湛的，有满篇幅转载抄袭的，各种文章看的眼花缭乱，重复性文章更是多如牛毛，我还是不要去掺和为好。 这里是我个人知识生活的一个记录，希望以后回想起来能有个念想。毕竟头脑不太好，能记住的东西有限，还是写下来更为妥当。 死亡并不可怕，等死才可怕。学习并不胆怯，无知才恐慌。学习的越多，才会发现越多没有学。 越往后学习，就会越来越发现人的强大，知识的丰富，个人的渺小。就越会对未知产生恐慌，就越会盲目的学习。这就是我目前害怕的地方。 你要知道什么时候自己知道，什么时候自己不知道，什么是自己知道的，什么是自己不知道的，要非常小心，不要自己把自己给骗了 感慨 活着是一种修行！ 时过境迁物是人非，本是过客，何必千千情结！ 不要对社会的不公平太惆怅，这个世界本来就不是公平的。 看待事情的时候从对立面考虑一下或许另有一番景色。 道理大都是长大了才懂，我们大多数人都只是一个平凡人，一个普通人。但是也不要去轻易否定自己，同时不要将自己是一个平凡人作为接口而不去努力，切记！ ​ 二〇一九年十一月二十日 星期三 18:57","link":"/article/2019.12/%E4%B8%87%E7%89%A9%E4%B9%8B%E5%A7%8B/"},{"title":"常用的设计模式总结(二)","text":"创建型模式之单例模式单例模式的概念单例模式值该类只有一个实例，且该类能够自行创建供其它类使用。 主要解决一个全局使用的类频繁的创建与销毁，该模式可以减少了系统性能的开销。 单例模式的分类 懒汉式：线程不安全，调用效率高，但是不能延迟加载 饿汉式：线程安全，调用效率不高，但是可以延迟加载 双重检测锁：线程不安全（由于JVM底层内部模型的指令重排） 静态内部类：线程安全，调用效率高，并且可以延迟加载 枚举单例：线程安全，调用效率高，但是不能延迟加载 懒汉式懒汉式是类初始化的时候不立即加载这个对象，当需要的时候再加载。 无论那种单例模式首先的第一步就是将该类的构造方法私有化！ 懒汉式需要注意的是需要加上synchronized关键字，如果不加上synchronized关键字，在多线程下会有存在不是单例的情况！ 代码如下： 1234567891011121314151617181920212223public class LazySingleton { private static LazySingleton instance = null; /** * 私有化构造方法 */ private LazySingleton() { } /** * 得到singleton的对象 * * @return 单例的LazySingleton */ public synchronized static LazySingleton getInstance() { if (instance == null) { instance = new LazySingleton(); } return instance; }} 这里还是解释一下如果不加上synchronized会造成不安全的原因： 首先假设有两个线程同时运行，此时第一个线程先调用LazySingleton.getInstance方法得到对象，此时先行判断instance是否为null，此时还没有执行到instance = new LazySingleton();所以可以进入if语句。但是此时可能第一个线程停住了，由第二个线程开始执行LazySingleton.getInstance，同样的进入了先判断instance是否为null，此时第一个线程并未执行到初始化对象的那一句，所以instance任然为null，依旧会进入if语句。所以会打破单例。如果加上synchronized，则第一个线程进入getInstance方法，即使轮询到其它线程执行，其它线程也执行不了getInstance方法，只有等到第一个线程的getInstance方法执行完成得到对象其它线程才可以执行。 想要试验的，可以在idea中打上Thread的类型的断电去调试一下。 饿汉式类初始化时立即加载这个对象，此时单例的对象可以申明final的 代码如下： 123456789101112131415161718public class HungrySingleton implements Serializable { private static final HungrySingleton INSTANCE = new HungrySingleton(); /** * 私有化构造方法 */ private HungrySingleton() { } /** * 返回单例对象 * * @return 返回单例对象 */ public static HungrySingleton getInstance() { return INSTANCE; }} 双重检测锁双重检测锁也可以产生单例对象，但是由于JVM底层内部模型的原因，指令重排，线程不安全，偶尔会出现问题，不建议使用。 指令重排是针对的实例化对象的那行代码，实际上可以分为三个步骤 分配内存给这个对象 初始化对象 设置lazyDoubleCheckSingleton 指向刚分配的内存地址 但是有些编译器为了性能的原因，可能会将第二步和第三步进行重排序，顺序就成了： 分配内存给这个对象 设置lazyDoubleCheckSingleton 指向刚分配的内存地址 初始化对象 此时如果是多线程的情况下，仍然有可能发生第一个线程执行完成了1，2步骤也就是分配内存和指向刚分配的内存地址，此时没有初始化这个对象，所以此时这个对象仍然为null，所以第二个线程仍然可能进入方法，返回不同的对象。 要解决双重检测锁的方法是给返回的单例对象加上volatile关键字 代码如下： 12345678910111213141516171819202122232425public class LazyDoubleCheckSingleton { // 这里加上volatile关键字 private volatile static LazyDoubleCheckSingleton lazyDoubleCheckSingleton = null; private LazyDoubleCheckSingleton() { } public static LazyDoubleCheckSingleton getInstance() { if (lazyDoubleCheckSingleton == null) { synchronized (LazyDoubleCheckSingleton.class) { if (lazyDoubleCheckSingleton == null) { // 在单线程中，这里是允许进行指令重排序的 // 1.分配内存给这个对象 // 2.初始化对象 // 3.设置lazyDoubleCheckSingleton 指向刚分配的内存地址 // 这里的2和3是有可能指令重排的 lazyDoubleCheckSingleton = new LazyDoubleCheckSingleton(); } } } return lazyDoubleCheckSingleton; }} 静态内部类12345678910111213public class StaticInnerClassSingleton { private static class InnerClass { private static StaticInnerClassSingleton staticInnerClassSingleton = new StaticInnerClassSingleton(); } private StaticInnerClassSingleton() { } public static StaticInnerClassSingleton getInstance() { return InnerClass.staticInnerClassSingleton; }} 枚举单例123456789101112131415161718192021222324252627282930313233public class EnumSigletonUser { /** * 私有化构造函数 */ private EnumSigletonUser() { } private enum SingletonUser { /** * 创建一个枚举对象，该对象天生为单例 */ INSTANCE; private EnumSigletonUser enumSigletonUser; SingletonUser() { this.enumSigletonUser = new EnumSigletonUser(); } public EnumSigletonUser getSingletonUser() { return enumSigletonUser; } } /** * 得到User单例 * * @return ser单例 */ public static EnumSigletonUser getInstance() { return SingletonUser.INSTANCE.getSingletonUser(); }} 破坏单例如果只是简单的使用，上面的单例代码是没有问题的。但是想要保证安全性，那么需要了解一下如果破坏单例，才能够去方式破坏。 通过序列化破坏代理 下面的代码是使用序列化的方式进行破坏单例 12345678910111213@Testpublic void destroySingletonBySerializationTest() throws IOException, ClassNotFoundException{ HungrySingleton instance = HungrySingleton.getInstance(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(\"F:\\\\singletonFile\")); objectOutputStream.writeObject(instance); ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(\"F:\\\\singletonFile\")); HungrySingleton hungrySingleton = (HungrySingleton) objectInputStream.readObject(); System.out.println(instance); System.out.println(hungrySingleton); System.out.println(instance == hungrySingleton);} 如何解决呢？方式是给单例的类加上一个readResolve方法，返回单例的对象 12345678/*** 解决序列化破坏单例* * @return 返回单例对象*/private Object readResolve() { return INSTANCE;} 通过反射攻击单例模式 1234567891011121314@Testpublic void destroySingletonByReflectionTest() throws Exception { Class hungryClass = HungrySingleton.class; Constructor constructor = hungryClass.getDeclaredConstructor(); // 强制修改单例类构造方法的修饰符为public constructor.setAccessible(true); HungrySingleton hungrySingleton = HungrySingleton.getInstance(); HungrySingleton reflexHungrySingleton = ((HungrySingleton) constructor.newInstance()); System.out.println(hungrySingleton); System.out.println(reflexHungrySingleton); System.out.println(hungrySingleton == reflexHungrySingleton);} 如何解决呢？对于饿汉式和静态内部类式，可以在私有的构造方法中进行判断当前的对象是否为null 1234567private HungrySingleton() { // 反射防御的代码 // 对于饿汉式和静态内部类式这种是有效的，其它的方式是无法避免反射攻击的 if (HUNGRY_SINGLETON != null) { throw new RuntimeException(\"禁止使用反射破坏单例!\"); }} 通过反射进行攻击，对于懒汉式来说，下面这两行代码如果颠倒顺序，那么就会出现不同的结果 12HungrySingleton reflexHungrySingleton = ((HungrySingleton) constructor.newInstance());HungrySingleton hungrySingleton = HungrySingleton.getInstance(); 如果是先反射构造单例，再通过单例类得到单例对象，那么在构造方法中判断null是有效的 但是如果是先得到单例对象，然后通过反射构造单例，那么在构造方法中判断null是无效的 原因是如果先通过单例类得到单例对象，那么此时的 然而对于饿汉式和静态内部类式在构造方法中进行判断当前的对象是否为null是有效的，无论两者的顺序是否不同，那是因为饿汉式和静态内部类是不能延迟加载，也即是在类初始化的时候就已经得到单例对象了。 枚举单例既可以防止序列化破坏也可以防止反射攻击。 如有错误，欢迎留言指正！ ​ 二〇一九年十二月二十一日 星期六 17:50","link":"/article/2019.12/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"常用的设计模式总结(一)","text":"常用的设计模式总结(一)设计模式的目的设计模式的目的是为了让程序，具有更好的代码重用性、可读性（编程规范性，便于后期维护和理解）、可扩展性（当需要增加新需求时，非常方便）、可靠性（增加新功能后，对原功能会有影响）、使程序呈现高内聚，低耦合的特性。设计模式包含了面向对象的精髓，“懂了设计模式，就懂得了面向对象分析和设计（OOA/D）的核心”。 虽说在平时开发简单的CRUD的时候可能用到的设计模式并不多，但是如果代码需要重构，需要优化，或者自己去设计一个项目的时候设计模式还是非常重要的！掌握一些常用的设计模式也是非常必要的！ 简单的介绍设计模式的七大原则12 开闭原则：一个软件实体如类、模块和函数应该对扩展开放（提供方）、对修改关闭（使用方） 开闭原则的作用就是在不修改软件源代码的前提下，可以扩展模块的功能。这里的不修改软件源代码指的是不修改已经写好的代码。 开闭原则的实现方法可以通过“抽象约束、封装变化”来实现，即通过设计合理的接口或者抽象类来为软件实体定义一个相对稳定的抽象层，而将可变因素封装在具体实现类中。因此抽象的设计就变得尤为重要，只要抽象的合理，就可以基本保持架构的稳定，而软件中异变的细节可以从抽象派生出来的实现类来进行扩展。当软件需求发生改变时候，只需要重新派生一个实现类就可以来实现扩展了。 里氏替换原则：所有引用基类的地方必须能透明地使用其子类的对象，子类可以扩展父类的功能，但不能改变父类原有的功能。 里氏替换原则通俗来讲就是子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。如果通过重写父类的方法来完成新功能，这样写虽然简单，但是整个继承体系的可复用性较差，特别是使用多态的时候，容易出现问题。 企鹅、鸵鸟和几维鸟从生物学的角度来划分，它们属于鸟类，但是它们并不能飞翔。所以从类的继承关系来看，它们不能继承“鸟”的飞这个方法并去重写“飞”这个方法，所以它们不能定义成“鸟”的子类。 单一职责原则：单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分 单一职责从名字来看就已经很明了了，一个类、接口和方法只负责一项职责，这样可以降低类的复杂度，提供系统的可维护性。如果单一职责原则遵循得好，当修改一个功能时，可以显著降低对其他功能的影响。 接口和方法必须是单一职责，而类的单一职责视情况而定。 接口隔离原则：客户端不应该依赖它不需要的接口类，类之间的依赖关系应该建立在最小的接口上 一句话，就是实现接口的类中，有多余的方法时，需要将接口进行拆分。接口尽量小，但是要有限度，一个接口只服务于一个子模块或业务逻辑。 依赖倒置原则：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象 其核心思想是：要面向接口、抽象编程，不要面向实现编程，这样就降低了客户与实现模块间的耦合。 依赖倒置原则的实现需要注意的是每个类尽量提供接口或者抽象类，或者两者都具备。变量的声明类型尽量是接口或者抽象类。任何类都不应该从具体类派生。使用继承时尽量遵循里氏替换原则 迪米特法则：又叫最少知道原则，一个软件实体应尽可能少地与其他实体发生相互作用 迪米特法则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块独立，相互之间不存在（或很少有）依赖关系。迪米特法则不希望类之间建立直接的关系。如果真的有需要建立联系，也希望能通过它的中间类来转达。 迪米特法则的实现可以从两个角度来看 从依赖者的角度来看，只依赖应该依赖的对象 从被依赖者的角度来看，只暴露应该暴露的方法 合成复用原则：在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现 如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。 通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点： 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。 合成复用原则的实现是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。 设计模式分类根据目的、用途不同分为三大类：创建型、结构型、行为型 创建型：创建型模式提供了一种在创建对象的同时隐藏创建逻辑的方式。主要特点是将对象的创建与使用分离，使得这些程序在判断针对某个给定实例需要创建哪些对象时更加灵活，这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，只需要使用对象即可。 单例模式 懒汉式 饿汉式 双重检测锁 静态内部类 枚举单例 工厂模式 简单工厂 工厂方法（类创建模式） 抽象工厂 建造者模式 原型模式 结构型：结构性关注类和对象的组合，描述的是如何将类与对象按某种布局组成更大的结构。 适配器模式（类结构型模式和对象结构型模式） 代理模式 装饰模式 外观模式 享元模式 桥接模式 组合模式 行为型：行为型用于描述程序在运行时复杂的流程控制，或者说多个对象之间的通信。即描述多个类或对象之间怎样相互协作共同完成单个对象无法完成的任务。 责任链模式 策略模式 模板方法（类行为型模式） 状态模式 迭代器模式 中介者模式 命令模式 解释器模式（类行为型模式） 访问者模式 观察者模式 备忘录模式 根据处理范围不同，设计模式又可分为类模式和对象模式类模式处理类与子类的关系，通过处理这些关系来建立继承，属于静态关系，在编译时候确定下来。 对象模式处理对象之间的关系，运行时发生变化，属于动态关系。 注：在上面中的设计模式除了特别标注的是类模式，其它的都是对象模式 上面设计模式中加粗的是比较常用并且重要的，需要特别记住，在各种框架中都有运用，用到的时候希望可以能够记起来并且灵活运用。需要记住的是，有时候设计模式不是绝对的！ 如有错误，欢迎留言指正！ ​ 二〇一九年十二月十三日 星期五 12:38 1.C语言中文网 设计模式 ↩2.CSDN 设计模式-七大原则 ↩","link":"/article/2019.12/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"常用的设计模式总结（四）","text":"代理模式介绍：通过代理，为其它对象提供一种代理以控制对这个对象的访问。可以详细控制访问某个（某类）对象的方法，我们可以在调用这个方法前做前置处理等操作 代理模式的角色Subject（抽象角色）：定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法 Real Subject（真实角色）：真正实现业务逻辑的类 Proxy（代理角色）：用来代理和封装真实角色 代理模式的优缺点优点 代理模式能够将代理对象与真实被调用的目标对象分离 一定程度上降低了系统的耦合度，扩展性好 保护目标对象、增强目标对象 缺点 代理模式会造成系统中的类的数据增加 在客户端目标对象加一个代理对象，会造成请求处理速度，慢 增加系统的复杂度 代理模式的分类 静态代理 动态代理 JDK动态代理 CGLib动态代理 理解 ​ 静态代理是显式地定义一个实现类的代理。在代理之前，所有的东西都是已知的，即知道我们所需要代理的类和方法 ​ 动态代理所有东西都是未知的，即不知道需要代理的类和方法 静态代理静态代理比较好理解，直接上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Order { private Object orderInfo; private Integer userId;}// 抽象角色public interface OrderService { /** * 添加Order * @param order order * @return 影响行数 */ int saveOrder(Order order);}// 真实角色public class OrderServiceImpl implements OrderService { /** * 添加Order * @param order order * @return 影响行数 */ @Override public int saveOrder(Order order) { System.out.println(\"Service层调用Dao层添加Order\"); return 1; }}// 代理角色public class OrderServiceStaticProxy { // 被代理的类 private OrderService orderService; public int saveOrder(Order order) { beforeMethod(order); // 我们知道被代理的类和所需要的方法 orderService = new OrderServiceImpl(); int result = orderService.saveOrder(order); afterMethod(); return result; } private void beforeMethod(Order order) { System.out.println(\"静态代理 before code\"); } private void afterMethod() { System.out.println(\"静态代理 after code\"); }} 静态代理比较理解并且容易实现，但是当场景复杂起来，当我们一旦修改了抽象角色当中需要代理的方法，那么对于代理类也是需要修改的，不易维护。 动态代理JDK动态代理动态代理的实现JDK动态代理是通过实现接口的方式来实现的，也就是我们需要一个接口，抽象对外的动作 JDK动态代理主要涉及两个类：java.lang.reflect.Proxy 和 java.lang.reflect.InvocationHandler。 这里我们依旧是对刚才的OrderServiceImpl做代理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class OrderServiceDynamicProxy implements InvocationHandler { /** * 被代理的真实对象 */ private Object proxyTarget; public OrderServiceDynamicProxy(Object proxyTarget) { this.proxyTarget = proxyTarget; } /** * 得到代理对象 * * @return 代理对象 */ public Object getProxyObject() { Class&lt;?&gt; targetClass = proxyTarget.getClass(); return Proxy.newProxyInstance(targetClass.getClassLoader(), targetClass.getInterfaces(), this); } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { beforeMethod(args); // 执行代理的方法 Object returnResult = method.invoke(this.proxyTarget, args); afterMethod(returnResult); return returnResult; } private void beforeMethod(Object[] args) { for (Object arg : args) { System.out.println(\"代理方法的参数 \" + arg.toString()); } System.out.println(\"动态代理 before code\"); } private void afterMethod(Object returnResult) { System.out.println(\"得到代理方法返回之后的结果 \" + returnResult.toString()); System.out.println(\"动态代理 after code\"); }}/** * 测试方法 **/@Testpublic void dynamicProxy() { Order order = new Order(); order.setUserId(2); OrderService orderServiceDynamicProxy = (OrderService) new OrderServiceDynamicProxy(new OrderServiceImpl()).getProxyObject(); orderServiceDynamicProxy.saveOrder(order);}=====结果=====代理方法的参数 Order{orderInfo=null, userId=2}动态代理 before codeService层调用Dao层添加Order得到代理方法返回之后的结果 1动态代理 after code 每一个动态代理类都必须要实现InvocationHandler这个接口，并实现其中的invoke方法，并且每个代理类的实例都关联到了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的invoke 方法来进行调用。 1public Object invoke(Object proxy, Method method, Object[] args) throws Throwable invoke的三个参数 proxy：所代理的那个真实对象 method：所要调用真实对象的某个方法的Method对象 args：调用真实对象某个方法时接受的参数 然后就是Proxy这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，但是我们用的最多的就是 newProxyInstance 这个方法 1public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) newProxyInstance的三个参数 loader：一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载【ClassLoader即类加载器，用来加载类到内存中】 interfaces：一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了。也就是抽象角色，其中有着对外提供的方法。 h：一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上 动态代理的过程 拿到被代理的对象的引用，并且去得到它的所有接口，反射获取 JDK Proxy重新生成一个新的类，同时新的类的实现被代理类的所有实现 动态生成Java代码，把新加的业务逻辑方法由一定的逻辑代码去调用 编译新生成的Java代码.class 再重新加载到JVM中运行 这上面的过程就是字节码的重组 JDK动态代理为什么不能通过继承实现？这里我们只需要把上面动态代理过程中第四步中心编译新生成的Java代码取出研究一下就知道了 将JDK动态代理生成的class文件保存到本地，只需要加上一行代码 1234System.getProperties().put(\"jdk.proxy.ProxyGenerator.saveGeneratedFiles\", \"true\");可以双击Shift去查找ProxyGenerator，可以看到该类在java.lang.reflect中private static final boolean saveGeneratedFiles = (Boolean)AccessController.doPrivileged(new GetBooleanAction(\"jdk.proxy.ProxyGenerator.saveGeneratedFiles\")); 但是需要注意这是新版的JDK的写法，我这边是JDK11.0.6。如果是低版本的JDK，如果JDK8，则是下面的这种写法。 还有这行代码是需要写在main方法中的，如果在Junit的Test方法中则调用无法生成。 1System.getProperties().put(\"\"sun.misc.ProxyGenerator.saveGeneratedFiles\", \"true\"); 最后得到相应的代理$Proxy0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public final class $Proxy0 extends Proxy implements OrderService { private static Method m1; private static Method m3; private static Method m2; private static Method m0; public $Proxy0(InvocationHandler var1) throws { super(var1); } public final boolean equals(Object var1) throws { try { return (Boolean)super.h.invoke(this, m1, new Object[]{var1}); } catch (RuntimeException | Error var3) { throw var3; } catch (Throwable var4) { throw new UndeclaredThrowableException(var4); } } // 这里便是代理的我们的方法 public final int saveOrder(Order var1) throws { try { return (Integer)super.h.invoke(this, m3, new Object[]{var1}); } catch (RuntimeException | Error var3) { throw var3; } catch (Throwable var4) { throw new UndeclaredThrowableException(var4); } } public final String toString() throws { try { return (String)super.h.invoke(this, m2, (Object[])null); } catch (RuntimeException | Error var2) { throw var2; } catch (Throwable var3) { throw new UndeclaredThrowableException(var3); } } public final int hashCode() throws { try { return (Integer)super.h.invoke(this, m0, (Object[])null); } catch (RuntimeException | Error var2) { throw var2; } catch (Throwable var3) { throw new UndeclaredThrowableException(var3); } } static { try { m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", Class.forName(\"java.lang.Object\")); m3 = Class.forName(\"com.april.proxy.OrderService\").getMethod(\"saveOrder\", Class.forName(\"com.april.proxy.Order\")); m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\"); m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\"); } catch (NoSuchMethodException var2) { throw new NoSuchMethodError(var2.getMessage()); } catch (ClassNotFoundException var3) { throw new NoClassDefFoundError(var3.getMessage()); } }} 可以看到自动生成的代理类是已经继承了Proxy类的，由于Java是单继承的，所以 CGLib动态代理CGLIB是一个强大、高性能的字节码生成库，它用于在运行时扩展Java类和实现接口；本质上它是通过动态的生成一个子类去覆盖所要代理的类（非final修饰的类和方法），所以CGLib动态代理是通过继承实现的。Enhancer是一个非常重要的类，它允许为非接口类型创建一个JAVA代理，Enhancer动态的创建给定类的子类并且拦截代理类的所有的方法，和JDK动态代理不一样的是不管是接口还是类它都能正常工作。1 这里接着对上面的OrderServiceImpl进行代理，此时可以不需要OrderService接口了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465** * @author AprilViolet * @version V1.0.0 * @projectName GitFlowDemo * @description 实现代理的类 * @date 2020.01.27 星期一 22:00 */public class CglibProxy implements MethodInterceptor { /** * 真实的被代理的类 */ private Object object; public Object createProxy(Object object) { this.object = object; Enhancer enhancer = new Enhancer(); // 设置代理目标 enhancer.setSuperclass(this.object.getClass()); // 设置单一回调回调，在调用中拦截目标方法的调用 enhancer.setCallback(this); // 设置类加载器 enhancer.setClassLoader(this.object.getClass().getClassLoader()); return enhancer.create(); } /** * 当对基于代理的方法回调时，在调用原方法之前会调用该方法 * * @param object 代理对象 * @param method 拦截的方法 * @param args 拦截的方法的参数 * @param methodProxy 代理 * @return 代理对象 * @throws Throwable Exception */ @Override public Object intercept(Object object, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { before(); Object result = methodProxy.invokeSuper(object, args); after(); return result; } private void before() { System.out.println(\"before method invoke...\"); } private void after() { System.out.println(\"after method invoke...\"); }}@Testpublic void cglibProxyTest() { OrderServiceImpl orderService = new OrderServiceImpl(); OrderServiceImpl proxy = (OrderServiceImpl) new CglibProxy().createProxy(orderService); proxy.saveOrder(new Order());}=====结果=====before method invoke...Service层调用Dao层添加Orderafter method invoke... 详细的CGlib使用可以参考 参考一 动态代理的原理图 2 如有错误，欢迎留言指正！ ​ 二〇二〇年一月二十八日 星期二 20:38 1.参考一 ↩1.参考二 ↩","link":"/article/2020.01/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"生活","slug":"生活","link":"/tags/%E7%94%9F%E6%B4%BB/"}],"categories":[{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"生活","slug":"生活","link":"/categories/%E7%94%9F%E6%B4%BB/"},{"name":"设计模式","slug":"Java/设计模式","link":"/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"博客","slug":"生活/博客","link":"/categories/%E7%94%9F%E6%B4%BB/%E5%8D%9A%E5%AE%A2/"}]}