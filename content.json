{"pages":[{"title":"瞬间光影","text":"","link":"/album/index.html"},{"title":"听到涛声的个人博客","text":"个人简介个人信息 普通本科软件工程专业、2020.06大学毕业 目前主要从事Java后端开发，禅系程序猿 平淡的大学生活，没有啥起伏 好一口二次元、喜欢安静一点 万里路需要走，大好河山要看，万卷书也要读，学习更不能停 关于本站本站介绍：本站属于我的个人博客网站，建立本站的初衷也是为了巩固自己所学和记录自己的学习并且分享出去，当然也会记录一些生活事情。个人目前的主要技术方向是Java开发，也会了解一些web前端和大数据相关。 本站概括：本站目前基于hexo搭建，采用的是Icarus主题。发布在GitHub，使用GitHubPage自动部署静态网页。未来可能也会发布在码云来加速国内的访问。 联系方式：您可以给我发邮件:AprilEternityLT@163.com 岁月仍静好 活着是一种修行 起风了，唯有努力生存 生活本不易，流人遂自安 世间安得两全法，不负如来不负卿 男儿有胆气，仗剑走天涯 女儿有剑心，柔情满山岗 平凡的世界平凡的我做着平凡的事情活在平凡的世界 一剪闲云一溪月，一程山水一年华 一世浮生一刹那，一树菩提一烟霞 往事尘烟","link":"/about/index.html"},{"title":"友链","text":"申请友链须知 - 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 - 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 - 申请链接前请先添加本博链接，请留言或者发邮件告知。 - 申请请提供：站点名称、站点链接、站点描述、logo或头像。 - 会定期清理不符合要求的友链，另行通知。 - 欢迎各位有志之士，望不吝珠玉","link":"/friend/index.html"},{"title":"留言专区","text":"畅所欲言，有留必应 如不能及时回复，您可以发邮件给我 PS：如果想要回复有头像的显示，可以去Gravatar注册并登录，回复的时候留下注册的邮箱即可。","link":"/message/index.html"},{"title":"聆听音乐","text":"&nbsp;&nbsp;静下心来，享受一下","link":"/music/index.html"}],"posts":[{"title":"万物之始","text":"喜大普奔 博客上线从大四下学期的十月底开始捣鼓这个博客，到现在也快一个月了，中途因为校招找工作耽误了许久，终于还是被我捣鼓出来了。说实在的中途也想要过放弃不弄了(≧﹏ ≦)因为中途的一些事情，但是最终还是坚持下去，把博客上线了。未来或许会经常更新或许会鸽，但是我一直都在，坚持就是胜利，加油，奥利给！ 有任何问题您可以联系我 想说的一些话目的最初就一直想有一个可以记录学习历程的地方，虽然自己也都有记笔记，但是笔记和写博客还是有区别的。费曼有一句话是这样说的：把你学到的知识，用你自己的、最简单的话，讲给一个外行、一个小孩子听，如果这些人都听懂了，你就真的懂了。 在如今信息爆炸的时代，你要知道什么时候自己知道，什么时候自己不知道，什么是自己知道的，什么是自己不知道的，要非常小心，不要自己把自己给骗了 当然我的博客也不仅仅是写一些自己的学习记录，也会记录一些自己的生活日常，可以说是写日记了，哈哈 感慨 活着是一种修行！ 时过境迁物是人非，本是过客，何必千千情结！ 不要对社会的不公平太惆怅，这个世界本来就不是公平的。 看待事情的时候从对立面考虑一下或许另有一番景色。 道理大都是长大了才懂，我们大多数人都只是一个平凡人，一个普通人。但是也不要去轻易否定自己，同时不要将自己是一个平凡人作为接口而不去努力，切记！ ​ 二〇一九年十一月二十日 星期三 18:57","link":"/2019/11/02/2019.12/%E4%B8%87%E7%89%A9%E4%B9%8B%E5%A7%8B/"},{"title":"常用的设计模式总结（三）","text":"工厂模式作用：工厂模式主要实现了创建和和调用者的分离 工厂模式的分类 简单工厂模式 工厂方法模式 抽象工厂模式 简单工厂模式简单工厂模式主要是由抽象的产品公共接口、具体的产品，生产产品的工厂组成的。 123456789101112131415161718192021222324252627282930313233public abstract class AbstractVideo { /** * 生产课程的 */ abstract void produce();}public class GoVideo extends AbstractVideo { @Override void produce() { System.out.println(\"录制Go课程视频\"); }}public class JavaVideo extends AbstractVideo { @Override void produce() { System.out.println(\"录制Java课程视频\"); }}public class VideoFactory { public AbstractVideo getVideo(String videoName) { // 封装主要的生产逻辑 if (\"java\".equals(videoName)) { return new JavaVideo(); } else if (\"go\".equals(videoName)) { return new GoVideo(); } return null; }} 但是简单工厂模式违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。 工厂方法模式工厂方法模式通过定义一个抽象工厂，将类的实例化延迟到抽象工厂的子类中完成，即由子类来决定应该创建哪一个类。 相较于简单工厂主要增加了抽象工厂这个抽象类，将具体的创建对象交给不同的工厂工厂的子类去完成，然后在得到工厂的时候就可以选择不同的工厂类。 12345678910111213141516171819202122232425public abstract class AbstractVideoFactory { /** * 得到课程 * * @return 课程 */ abstract AbstractVideo getVideo();}public class GoVideoFactory extends AbstractVideoFactory { @Override AbstractVideo getVideo() { return new GoVideo(); }}public class FactoryMethodTest { @Test public void factoryMethodTest() { AbstractVideoFactory videoFactory1 = new JavaVideoFactory(); AbstractVideoFactory videoFactory2 = new GoVideoFactory(); videoFactory1.getVideo().produce(); videoFactory2.getVideo().produce(); }} 但是这种方式就增加了系统的复杂度：类的个数将成对增加。 抽象工厂模式1抽象工厂模式是工厂方法模式的升级版本，它用来创建一组相关或者相互依赖的对象。 它与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。 在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。 在抽象工厂模式中，有一个产品族的概念：所谓的产品族，是指位于不同产品等级结构中功能相关联的产品组成的家族。抽象工厂模式所提供的一系列产品就组成一个产品族；而工厂方法提供的一系列产品称为一个等级结构。 如果工厂的产品全部属于同一个等级结构，则属于工厂方法模式；如果工厂的产品来自多个等级结构，则属于抽象工厂模式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public abstract class AbstractArticle { /** * 生产视频文章 */ abstract void produce();}public abstract class AbstractVideo { /** * 生产视频 */ abstract void produce();}public class JavaArticle extends AbstractArticle { @Override void produce() { System.out.println(\"编写Java课程手记\"); }}public class JavaVideo extends AbstractVideo { @Override void produce() { System.out.println(\"录制Java课程视频\"); }}public interface CourseFactory { AbstractVideo getVideo(); AbstractArticle getArticle();}public class JavaCourseFactory implements CourseFactory { @Override public AbstractVideo getVideo() { return new JavaVideo(); } @Override public AbstractArticle getArticle() { return new JavaArticle(); }}public class AbstractFactoryTest { @Test public void abstractFactoryTest() { CourseFactory courseFactory = new JavaCourseFactory(); courseFactory.getVideo().produce(); courseFactory.getArticle().produce(); }} 抽象工厂模式的优点抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是可以在类的内部对产品族进行约束。所谓的产品族，一般或多或少地都存在一定的关联，抽象工厂模式就可以在类内部对产品族的关联关系进行定义和描述，而不必专门引入一个新的类来进行管理。 抽象工厂模式的缺点产品族的扩展将是一件十分费力的事情，假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。所以使用抽象工厂模式时，对产品等级结构的划分是非常重要的。 使用场景当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。说得更明白一点，就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。假如各个等级结构中的实现类之间不存在关联或约束，则使用多个独立的工厂来对产品进行创建，则更合适一点。 如有错误，欢迎留言指正！ ​ 二〇一九年十二月十三日 星期五 12:38 1.博客园 java 三种工厂模式 ↩","link":"/2019/12/22/2019.12/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/"},{"title":"常用的设计模式总结(二)","text":"创建型模式之单例模式单例模式的概念单例模式值该类只有一个实例，且该类能够自行创建供其它类使用。 主要解决一个全局使用的类频繁的创建与销毁，该模式可以减少了系统性能的开销。 单例模式的分类 懒汉式：线程不安全，调用效率高，但是不能延迟加载 饿汉式：线程安全，调用效率不高，但是可以延迟加载 双重检测锁：线程不安全（由于JVM底层内部模型的指令重排） 静态内部类：线程安全，调用效率高，并且可以延迟加载 枚举单例：线程安全，调用效率高，但是不能延迟加载 懒汉式懒汉式是类初始化的时候不立即加载这个对象，当需要的时候再加载。 无论那种单例模式首先的第一步就是将该类的构造方法私有化！ 懒汉式需要注意的是需要加上synchronized关键字，如果不加上synchronized关键字，在多线程下会有存在不是单例的情况！ 代码如下： 1234567891011121314151617181920212223public class LazySingleton { private static LazySingleton instance = null; /** * 私有化构造方法 */ private LazySingleton() { } /** * 得到singleton的对象 * * @return 单例的LazySingleton */ public synchronized static LazySingleton getInstance() { if (instance == null) { instance = new LazySingleton(); } return instance; }} 这里还是解释一下如果不加上synchronized会造成不安全的原因： 首先假设有两个线程同时运行，此时第一个线程先调用LazySingleton.getInstance方法得到对象，此时先行判断instance是否为null，此时还没有执行到instance = new LazySingleton();所以可以进入if语句。但是此时可能第一个线程停住了，由第二个线程开始执行LazySingleton.getInstance，同样的进入了先判断instance是否为null，此时第一个线程并未执行到初始化对象的那一句，所以instance任然为null，依旧会进入if语句。所以会打破单例。如果加上synchronized，则第一个线程进入getInstance方法，即使轮询到其它线程执行，其它线程也执行不了getInstance方法，只有等到第一个线程的getInstance方法执行完成得到对象其它线程才可以执行。 想要试验的，可以在idea中打上Thread的类型的断电去调试一下。 饿汉式类初始化时立即加载这个对象，此时单例的对象可以申明final的 代码如下： 123456789101112131415161718public class HungrySingleton implements Serializable { private static final HungrySingleton INSTANCE = new HungrySingleton(); /** * 私有化构造方法 */ private HungrySingleton() { } /** * 返回单例对象 * * @return 返回单例对象 */ public static HungrySingleton getInstance() { return INSTANCE; }} 双重检测锁双重检测锁也可以产生单例对象，但是由于JVM底层内部模型的原因，指令重排，线程不安全，偶尔会出现问题，不建议使用。 指令重排是针对的实例化对象的那行代码，实际上可以分为三个步骤 分配内存给这个对象 初始化对象 设置lazyDoubleCheckSingleton 指向刚分配的内存地址 但是有些编译器为了性能的原因，可能会将第二步和第三步进行重排序，顺序就成了： 分配内存给这个对象 设置lazyDoubleCheckSingleton 指向刚分配的内存地址 初始化对象 此时如果是多线程的情况下，仍然有可能发生第一个线程执行完成了1，2步骤也就是分配内存和指向刚分配的内存地址，此时没有初始化这个对象，所以此时这个对象仍然为null，所以第二个线程仍然可能进入方法，返回不同的对象。 要解决双重检测锁的方法是给返回的单例对象加上volatile关键字 代码如下： 12345678910111213141516171819202122232425public class LazyDoubleCheckSingleton { // 这里加上volatile关键字 private volatile static LazyDoubleCheckSingleton lazyDoubleCheckSingleton = null; private LazyDoubleCheckSingleton() { } public static LazyDoubleCheckSingleton getInstance() { if (lazyDoubleCheckSingleton == null) { synchronized (LazyDoubleCheckSingleton.class) { if (lazyDoubleCheckSingleton == null) { // 在单线程中，这里是允许进行指令重排序的 // 1.分配内存给这个对象 // 2.初始化对象 // 3.设置lazyDoubleCheckSingleton 指向刚分配的内存地址 // 这里的2和3是有可能指令重排的 lazyDoubleCheckSingleton = new LazyDoubleCheckSingleton(); } } } return lazyDoubleCheckSingleton; }} 静态内部类12345678910111213public class StaticInnerClassSingleton { private static class InnerClass { private static StaticInnerClassSingleton staticInnerClassSingleton = new StaticInnerClassSingleton(); } private StaticInnerClassSingleton() { } public static StaticInnerClassSingleton getInstance() { return InnerClass.staticInnerClassSingleton; }} 枚举单例123456789101112131415161718192021222324252627282930313233public class EnumSigletonUser { /** * 私有化构造函数 */ private EnumSigletonUser() { } private enum SingletonUser { /** * 创建一个枚举对象，该对象天生为单例 */ INSTANCE; private EnumSigletonUser enumSigletonUser; SingletonUser() { this.enumSigletonUser = new EnumSigletonUser(); } public EnumSigletonUser getSingletonUser() { return enumSigletonUser; } } /** * 得到User单例 * * @return ser单例 */ public static EnumSigletonUser getInstance() { return SingletonUser.INSTANCE.getSingletonUser(); }} 破坏单例如果只是简单的使用，上面的单例代码是没有问题的。但是想要保证安全性，那么需要了解一下如果破坏单例，才能够去方式破坏。 通过序列化破坏代理 下面的代码是使用序列化的方式进行破坏单例 12345678910111213@Testpublic void destroySingletonBySerializationTest() throws IOException, ClassNotFoundException{ HungrySingleton instance = HungrySingleton.getInstance(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(\"F:\\\\singletonFile\")); objectOutputStream.writeObject(instance); ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(\"F:\\\\singletonFile\")); HungrySingleton hungrySingleton = (HungrySingleton) objectInputStream.readObject(); System.out.println(instance); System.out.println(hungrySingleton); System.out.println(instance == hungrySingleton);} 如何解决呢？方式是给单例的类加上一个readResolve方法，返回单例的对象 12345678/*** 解决序列化破坏单例* * @return 返回单例对象*/private Object readResolve() { return INSTANCE;} 通过反射攻击单例模式 1234567891011121314@Testpublic void destroySingletonByReflectionTest() throws Exception { Class hungryClass = HungrySingleton.class; Constructor constructor = hungryClass.getDeclaredConstructor(); // 强制修改单例类构造方法的修饰符为public constructor.setAccessible(true); HungrySingleton hungrySingleton = HungrySingleton.getInstance(); HungrySingleton reflexHungrySingleton = ((HungrySingleton) constructor.newInstance()); System.out.println(hungrySingleton); System.out.println(reflexHungrySingleton); System.out.println(hungrySingleton == reflexHungrySingleton);} 如何解决呢？对于饿汉式和静态内部类式，可以在私有的构造方法中进行判断当前的对象是否为null 1234567private HungrySingleton() { // 反射防御的代码 // 对于饿汉式和静态内部类式这种是有效的，其它的方式是无法避免反射攻击的 if (HUNGRY_SINGLETON != null) { throw new RuntimeException(\"禁止使用反射破坏单例!\"); }} 通过反射进行攻击，对于懒汉式来说，下面这两行代码如果颠倒顺序，那么就会出现不同的结果 12HungrySingleton reflexHungrySingleton = ((HungrySingleton) constructor.newInstance());HungrySingleton hungrySingleton = HungrySingleton.getInstance(); 如果是先反射构造单例，再通过单例类得到单例对象，那么在构造方法中判断null是有效的 但是如果是先得到单例对象，然后通过反射构造单例，那么在构造方法中判断null是无效的 原因是如果先通过单例类得到单例对象，那么此时的 然而对于饿汉式和静态内部类式在构造方法中进行判断当前的对象是否为null是有效的，无论两者的顺序是否不同，那是因为饿汉式和静态内部类是不能延迟加载，也即是在类初始化的时候就已经得到单例对象了。 枚举单例既可以防止序列化破坏也可以防止反射攻击。 如有错误，欢迎留言指正！ ​ 二〇一九年十二月二十一日 星期六 17:50","link":"/2019/12/19/2019.12/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"常用的设计模式总结(一)","text":"常用的设计模式总结(一)设计模式的目的设计模式的目的是为了让程序，具有更好的代码重用性、可读性（编程规范性，便于后期维护和理解）、可扩展性（当需要增加新需求时，非常方便）、可靠性（增加新功能后，对原功能会有影响）、使程序呈现高内聚，低耦合的特性。设计模式包含了面向对象的精髓，“懂了设计模式，就懂得了面向对象分析和设计（OOA/D）的核心”。 虽说在平时开发简单的CRUD的时候可能用到的设计模式并不多，但是如果代码需要重构，需要优化，或者自己去设计一个项目的时候设计模式还是非常重要的！掌握一些常用的设计模式也是非常必要的！ 简单的介绍设计模式的七大原则12 开闭原则：一个软件实体如类、模块和函数应该对扩展开放（提供方）、对修改关闭（使用方） 开闭原则的作用就是在不修改软件源代码的前提下，可以扩展模块的功能。这里的不修改软件源代码指的是不修改已经写好的代码。 开闭原则的实现方法可以通过“抽象约束、封装变化”来实现，即通过设计合理的接口或者抽象类来为软件实体定义一个相对稳定的抽象层，而将可变因素封装在具体实现类中。因此抽象的设计就变得尤为重要，只要抽象的合理，就可以基本保持架构的稳定，而软件中异变的细节可以从抽象派生出来的实现类来进行扩展。当软件需求发生改变时候，只需要重新派生一个实现类就可以来实现扩展了。 里氏替换原则：所有引用基类的地方必须能透明地使用其子类的对象，子类可以扩展父类的功能，但不能改变父类原有的功能。 里氏替换原则通俗来讲就是子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。如果通过重写父类的方法来完成新功能，这样写虽然简单，但是整个继承体系的可复用性较差，特别是使用多态的时候，容易出现问题。 企鹅、鸵鸟和几维鸟从生物学的角度来划分，它们属于鸟类，但是它们并不能飞翔。所以从类的继承关系来看，它们不能继承“鸟”的飞这个方法并去重写“飞”这个方法，所以它们不能定义成“鸟”的子类。 单一职责原则：单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分 单一职责从名字来看就已经很明了了，一个类、接口和方法只负责一项职责，这样可以降低类的复杂度，提供系统的可维护性。如果单一职责原则遵循得好，当修改一个功能时，可以显著降低对其他功能的影响。 接口和方法必须是单一职责，而类的单一职责视情况而定。 接口隔离原则：客户端不应该依赖它不需要的接口类，类之间的依赖关系应该建立在最小的接口上 一句话，就是实现接口的类中，有多余的方法时，需要将接口进行拆分。接口尽量小，但是要有限度，一个接口只服务于一个子模块或业务逻辑。 依赖倒置原则：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象 其核心思想是：要面向接口、抽象编程，不要面向实现编程，这样就降低了客户与实现模块间的耦合。 依赖倒置原则的实现需要注意的是每个类尽量提供接口或者抽象类，或者两者都具备。变量的声明类型尽量是接口或者抽象类。任何类都不应该从具体类派生。使用继承时尽量遵循里氏替换原则 迪米特法则：又叫最少知道原则，一个软件实体应尽可能少地与其他实体发生相互作用 迪米特法则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块独立，相互之间不存在（或很少有）依赖关系。迪米特法则不希望类之间建立直接的关系。如果真的有需要建立联系，也希望能通过它的中间类来转达。 迪米特法则的实现可以从两个角度来看 从依赖者的角度来看，只依赖应该依赖的对象 从被依赖者的角度来看，只暴露应该暴露的方法 合成复用原则：在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现 如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。 通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点： 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。 合成复用原则的实现是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。 设计模式分类根据目的、用途不同分为三大类：创建型、结构型、行为型 创建型：创建型模式提供了一种在创建对象的同时隐藏创建逻辑的方式。主要特点是将对象的创建与使用分离，使得这些程序在判断针对某个给定实例需要创建哪些对象时更加灵活，这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，只需要使用对象即可。 单例模式 懒汉式 饿汉式 双重检测锁 静态内部类 枚举单例 工厂模式 简单工厂 工厂方法（类创建模式） 抽象工厂 建造者模式 原型模式 结构型：结构性关注类和对象的组合，描述的是如何将类与对象按某种布局组成更大的结构。 适配器模式（类结构型模式和对象结构型模式） 代理模式 装饰模式 外观模式 享元模式 桥接模式 组合模式 行为型：行为型用于描述程序在运行时复杂的流程控制，或者说多个对象之间的通信。即描述多个类或对象之间怎样相互协作共同完成单个对象无法完成的任务。 责任链模式 策略模式 模板方法（类行为型模式） 状态模式 迭代器模式 中介者模式 命令模式 解释器模式（类行为型模式） 访问者模式 观察者模式 备忘录模式 根据处理范围不同，设计模式又可分为类模式和对象模式类模式处理类与子类的关系，通过处理这些关系来建立继承，属于静态关系，在编译时候确定下来。 对象模式处理对象之间的关系，运行时发生变化，属于动态关系。 注：在上面中的设计模式除了特别标注的是类模式，其它的都是对象模式 上面设计模式中加粗的是比较常用并且重要的，需要特别记住，在各种框架中都有运用，用到的时候希望可以能够记起来并且灵活运用。需要记住的是，有时候设计模式不是绝对的！ 如有错误，欢迎留言指正！ ​ 二〇一九年十二月十三日 星期五 12:38 1.C语言中文网 设计模式 ↩2.CSDN 设计模式-七大原则 ↩","link":"/2019/12/11/2019.12/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/"}],"tags":[{"name":"轨迹","slug":"轨迹","link":"/tags/%E8%BD%A8%E8%BF%B9/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"轨迹","slug":"轨迹","link":"/categories/%E8%BD%A8%E8%BF%B9/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"博客","slug":"轨迹/博客","link":"/categories/%E8%BD%A8%E8%BF%B9/%E5%8D%9A%E5%AE%A2/"},{"name":"设计模式","slug":"Java/设计模式","link":"/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}